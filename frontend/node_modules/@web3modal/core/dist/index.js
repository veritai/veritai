import{proxy as l,subscribe as u}from"valtio/vanilla";const s=l({initialized:!1,ethereum:void 0}),n={state:s,subscribe(e){return u(s,()=>e(s))},ethereum(){if(!s.ethereum)throw new Error("Ethereum client was not provided");return s.ethereum},async setEthereumClient(e){const{Web3ModalEthereum:t}=await import("@web3modal/ethereum");s.ethereum=t.createClient(e),s.initialized=!0}};function $(){return typeof matchMedia<"u"&&matchMedia("(prefers-color-scheme: dark)").matches}const h=l({configured:!1,projectId:"",theme:$()?"dark":"light",accentColor:"default"}),k={state:h,subscribe(e){return u(h,()=>e(h))},setConfig(e){if(!e.projectId)throw new Error("Web3Modal requires projectId that can be obtained at cloud.walletconnect.com");Object.assign(h,e),h.configured=!0}},p=l({open:!1}),ie={state:p,subscribe(e){return u(p,()=>e(p))},openModal(){p.open=!0},closeModal(){p.open=!1}};function W(){return{url:"https://explorer-api.walletconnect.com",projectId:k.state.projectId}}function N(e){const t=Object.fromEntries(Object.entries(e).filter(([r,a])=>typeof a<"u"&&a!==null&&a!=="").map(([r,a])=>[r,a.toString()]));return new URLSearchParams(t).toString()}function S(e){const{url:t,projectId:r}=W();return`${t}/v3/wallets?projectId=${r}&${N(e)}`}async function f(e){return(await fetch(S(e))).json()}const c=l({wallets:{listings:[],total:0,page:1},search:{listings:[],total:0,page:1},previewWallets:[]}),le={state:c,subscribe(e){return u(c,()=>e(c))},async getPreviewWallets(){const{listings:e}=await f({page:1,entries:10,version:1});return c.previewWallets=Object.values(e),c.previewWallets},async getPaginatedWallets(e){const{page:t,search:r}=e,{listings:a,total:w}=await f(e),m=Object.values(a),b=r?"search":"wallets";return c[b]={listings:[...c[b].listings,...m],total:w,page:t??1},{listings:m,total:w}},resetSearch(){c.search={listings:[],total:0,page:1}}},i=l({open:!1,message:"",variant:"success"}),ue={state:i,subscribe(e){return u(i,()=>e(i))},openToast(e,t){i.open=!0,i.message=e,i.variant=t},closeToast(){i.open=!1}},o=l({history:["ConnectWallet"],view:"ConnectWallet"}),he={state:o,subscribe(e){return u(o,()=>e(o))},push(e){o.view=e,o.history.push(e)},replace(e){o.view=e,o.history=[e]},goBack(){if(o.history.length>1){o.history.pop();const[e]=o.history.slice(-1);o.view=e}}},pe={watch(e,t){return n.ethereum().watchAccount(t)},get(){return n.ethereum().getAccount()},disconnect(){n.ethereum().disconnect()}};var T=Object.defineProperty,I=Object.defineProperties,A=Object.getOwnPropertyDescriptors,y=Object.getOwnPropertySymbols,B=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable,g=(e,t,r)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,M=(e,t)=>{for(var r in t||(t={}))B.call(t,r)&&g(e,r,t[r]);if(y)for(var r of y(t))D.call(t,r)&&g(e,r,t[r]);return e},L=(e,t)=>I(e,A(t));const x={watch(e,t){return n.ethereum().watchBlockNumber(L(M({},e),{listen:!0}),async()=>{const r=await x.fetch(e);t(r)})},async fetch(e){return await n.ethereum().fetchBalance(e)}};var R=Object.defineProperty,_=Object.defineProperties,F=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,H=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable,v=(e,t,r)=>t in e?R(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,z=(e,t)=>{for(var r in t||(t={}))H.call(t,r)&&v(e,r,t[r]);if(d)for(var r of d(t))U.call(t,r)&&v(e,r,t[r]);return e},K=(e,t)=>_(e,F(t));const we={watch(e,t){return n.ethereum().watchBlockNumber(K(z({},e),{listen:!0}),t)},async fetch(e){return await n.ethereum().fetchBlockNumber(e)}};var q=Object.defineProperty,J=Object.defineProperties,G=Object.getOwnPropertyDescriptors,O=Object.getOwnPropertySymbols,Q=Object.prototype.hasOwnProperty,V=Object.prototype.propertyIsEnumerable,C=(e,t,r)=>t in e?q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,X=(e,t)=>{for(var r in t||(t={}))Q.call(t,r)&&C(e,r,t[r]);if(O)for(var r of O(t))V.call(t,r)&&C(e,r,t[r]);return e},Y=(e,t)=>J(e,G(t));const me={get(e){return n.ethereum().getContract(e)},async read(e){return await n.ethereum().readContract(e)},async write(e){const t=await n.ethereum().prepareWriteContract(e);return await n.ethereum().writeContract(t)},watchRead(e,t){return n.ethereum().watchReadContract(Y(X({},e),{listenToBlock:!0}),t)},watchEven(e,t,r,a){return n.ethereum().watchContractEvent(e,t,r,a)}},be={async fetchEnsAddress(e){return await n.ethereum().fetchEnsAddress(e)},async fetchEnsAvatar(e){return await n.ethereum().fetchEnsAvatar(e)},async fetchEnsName(e){return await n.ethereum().fetchEnsName(e)},async fetchEnsResolver(e){return await n.ethereum().fetchEnsResolver(e)}};var Z=Object.defineProperty,ee=Object.defineProperties,te=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertySymbols,re=Object.prototype.hasOwnProperty,ne=Object.prototype.propertyIsEnumerable,P=(e,t,r)=>t in e?Z(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,ae=(e,t)=>{for(var r in t||(t={}))re.call(t,r)&&P(e,r,t[r]);if(j)for(var r of j(t))ne.call(t,r)&&P(e,r,t[r]);return e},oe=(e,t)=>ee(e,te(t));const ce={watch(e,t){return n.ethereum().watchBlockNumber(oe(ae({},e),{listen:!0}),async()=>{const r=await ce.fetch(e);t(r)})},async fetch(e){return await n.ethereum().fetchFeeData(e)}},fe={watch(e,t){return n.ethereum().watchNetwork(t)},get(){return n.ethereum().getNetwork()},async switchNetwork(e){return await n.ethereum().switchNetwork(e)}},ye={watch(e,t){return n.ethereum().watchProvider(e,t)},get(e){return n.ethereum().getProvider(e)}},ge={watch(e,t){return n.ethereum().watchSigner(t)},async fetch(){return await n.ethereum().fetchSigner()},async signMessage(e){return await n.ethereum().signMessage(e)},async signTypedData(e){return await n.ethereum().signTypedData(e)}},de={async fetch(e){return await n.ethereum().fetchToken(e)}},ve={async fetch(e){return await n.ethereum().fetchTransaction(e)},async send(e){const t=await n.ethereum().prepareSendTransaction(e);return await n.ethereum().sendTransaction(t)},async wait(e){return await n.ethereum().waitForTransaction(e)}},Oe={watch(e,t){return n.ethereum().watchWebSocketProvider(e,t)},get(e){return n.ethereum().getWebSocketProvider(e)}},E="WALLETCONNECT_DEEPLINK_CHOICE",Ce={isCoinbaseExtension(){return window.coinbaseWalletExtension},isMobile(){return Boolean(window.matchMedia("(pointer:coarse)").matches||/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent))},isEmptyObject(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.getOwnPropertyNames(e).length===0&&Object.getOwnPropertySymbols(e).length===0},formatNativeUrl(e,t,r){const a=e.replaceAll("/","").replaceAll(":","");return this.setWalletConnectDeepLink(a,r),`${a}://wc?uri=${t}`},formatUniversalUrl(e,t,r){let a=e;return e.endsWith("/")&&(a=e.slice(0,-1)),this.setWalletConnectDeepLink(a,r),`${a}/wc?uri=${t}`},async wait(e){return new Promise(t=>{setTimeout(t,e)})},openHref(e,t="_self"){window.open(e,t,"noreferrer noopener")},setWalletConnectDeepLink(e,t){localStorage.setItem(E,JSON.stringify({href:e,name:t}))},removeWalletConnectDeepLink(){localStorage.removeItem(E)}};export{pe as AccountCtrl,x as BalanceCtrl,we as BlockCtrl,n as ClientCtrl,k as ConfigCtrl,ie as ConnectModalCtrl,me as ContractCtrl,Ce as CoreHelpers,be as EnsCtrl,le as ExplorerCtrl,ce as FeeCtrl,ue as ModalToastCtrl,fe as NetworkCtrl,ye as ProviderCtrl,he as RouterCtrl,ge as SignerCtrl,de as TokenCtrl,ve as TransactionCtrl,Oe as WebSocketProviderCtrl,W as getExplorerApi};
//# sourceMappingURL=index.js.map
